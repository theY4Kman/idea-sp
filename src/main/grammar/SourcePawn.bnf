
{
  parserClass="org.idea_sp.parser.SourcePawnParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends(".*_expr")=expr

  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"

  psiClassPrefix="SourcePawn"
  psiImplClassSuffix="Impl"
  psiPackage="org.idea_sp.psi"
  psiImplPackage="org.idea_sp.psi.impl"

  elementTypeHolderClass="org.idea_sp.psi.SourcePawnTypes"
  elementTypeClass="org.idea_sp.psi.SourcePawnElementType"
  tokenTypeClass="org.idea_sp.psi.SourcePawnTokenType"

  tokens = [
    EQ="="
    EXCL="!"
    TILDE="~"
    QUEST="?"
    COLON=":"
    PLUS="+"
    MINUS="-"
    ASTERISK="*"
    DIV="/"
    OR="|"
    XOR="^"
    PERC="%"
    LPAREN="("
    RPAREN=")"
    LBRACE="{"
    RBRACE="}"
    LBRACKET="["
    RBRACKET="]"
    SEMICOLON=";"
    COMMA=","
    ELLIPSIS="..."
    DOT="."
    EQEQ="=="
    NE="!="
    OROR="||"
    PLUSPLUS="++"
    MINUSMINUS="--"
    LT="<"
    LE="<="
    LTLT="<<"
    GT=">"
    AND="&"
    ANDAND="&&"
    PLUSEQ="+="
    MINUSEQ="-="
    ASTERISKEQ="*="
    DIVEQ="/="
    ANDEQ="&="
    OREQ="|="
    XOREQ="^="
    PERCEQ="%="
    LTLTEQ="<<="
    GTGTEQ=">>="

    ASSERT_KEYWORD="assert"
    BREAK_KEYWORD="break"
    CASE_KEYWORD="case"
    CONTINUE_KEYWORD="continue"
    DEFAULT_KEYWORD="default"
    DO_KEYWORD="do"
    ELSE_KEYWORD="else"
    EXIT_KEYWORD="exit"
    FOR_KEYWORD="for"
    GOTO_KEYWORD="goto"
    IF_KEYWORD="if"
    RETURN_KEYWORD="return"
    SLEEP_KEYWORD="sleep"
    STATE_KEYWORD="state"
    SWITCH_KEYWORD="switch"
    WHILE_KEYWORD="while"

    DEFINED_KEYWORD="defined"
    SIZEOF_KEYWORD="sizeof"
    STATE_KEYWORD="state"
    TAGOF_KEYWORD="tagof"

    CONST_KEYWORD="const"
    FORWARD_KEYWORD="forward"
    NATIVE_KEYWORD="native"
    NEW_KEYWORD="new"
    OPERATOR_KEYWORD="operator"
    PUBLIC_KEYWORD="public"
    STATIC_KEYWORD="static"
    STOCK_KEYWORD="stock"

    DECL_KEYWORD="decl"
    NEW_KEYWORD="new"
    PUBLIC_KEYWORD="public"

    // SourcePawn-specific keywords
    ENUM_KEYWORD="enum"
    STRUCT_KEYWORD="struct"

    VIEW_AS_KEYWORD="view_as"

    VOID_TYPE="void"
    INT_TYPE="int"
    FLOAT_TYPE="float"
    CHAR_TYPE="char"
    BOOL_TYPE="bool"

    line_comment="regexp://[^\r\n]*"
    block_comment="regexp:/\*(.|\n)*?\*/"
    preprocessor_comment="regexp:#(assert|define|else|elseif|endif|endinput|error|file|if|include|line|pragma|section|tryinclude|undef)[^\r\n]*"

    integer_literal="regexp:[-+]?\d[_\d]*"
    float_literal="regexp:[-+]?\d[_\d]*\.\d[_\d]*(e[-+]?\d+)?"
    hex_literal="regexp:[-+]?0x[a-fA-F0-9_]+"
    binary_literal="regexp:[-+]?0b[01_]+"

    string_literal="regexp:\"(\\.|[^\"])*\""
    character_literal="regexp:'(\\.|[^\"])'"

    // @ and _ are not themselves valid identifiers.
    identifier="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"

    symbol="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"

    // TODO: remove me (for live preview purposes only)
    SPACE="regexp:[ \n\r\t\f]"
  ]
}

private root ::= global

private meta list ::= <<param>> ( COMMA <<param>> )*

private global ::= global_var_decl_statement
                 | func

global_var_decl_statement ::= global_var_decl SEMICOLON
                            | global_var_decl EQ global_var_initializer SEMICOLON

global_var_decl ::= global_var_storage_class? type_decl symbol
global_var_initializer ::= 'nevermind'

global_var_storage_class ::= STATIC_KEYWORD

type_decl ::= (builtin_type | symbol) (LBRACKET RBRACKET)*

private builtin_type ::= VOID_TYPE
                       | INT_TYPE
                       | FLOAT_TYPE
                       | CHAR_TYPE
                       | BOOL_TYPE

func ::= func_storage_class? type_decl symbol param_list stmt
private func_storage_class ::= PUBLIC_KEYWORD
                             | STOCK_KEYWORD STATIC_KEYWORD?
                             | STATIC_KEYWORD STOCK_KEYWORD?

param_list ::= LPAREN <<list param_decl>>? RPAREN
param_decl ::= CONST_KEYWORD? type_decl AND? symbol  // TODO: dims

private meta stmt_of ::= <<param>> | <<compound_stmt_of <<param>> >>
private meta compound_stmt_of ::= LBRACE <<param>>* RBRACE { pin = 1 }

private stmt ::= compound_stmt
               | single_stmt

private single_stmt ::= simple_stmt
                      | if_stmt
                      | switch_stmt
                      | for_loop
                      | while_loop
                      | do_while_loop
                      | return_stmt
private compound_stmt ::= <<compound_stmt_of stmt>>

private loop_stmt ::= <<stmt_of (single_stmt | continue_stmt | break_stmt)>>

private simple_stmt ::= simple_expression SEMICOLON { pin = 2 }
private simple_expression ::= expr
                            | local_decl

if_stmt ::= IF_KEYWORD LPAREN expr RPAREN stmt (ELSE_KEYWORD stmt)?

switch_stmt ::= SWITCH_KEYWORD LPAREN expr RPAREN LBRACE (switch_case | switch_default)* RBRACE
switch_case ::= CASE_KEYWORD <<list expr>> COLON stmt
switch_default ::= DEFAULT_KEYWORD COLON stmt

for_loop ::= FOR_KEYWORD LPAREN for_init? SEMICOLON for_condition? SEMICOLON for_iteration? RPAREN loop_stmt
private for_init ::= <<list simple_expression>>
private for_condition ::= expr
private for_iteration ::= expr

while_loop ::= WHILE_KEYWORD LPAREN while_condition RPAREN stmt
private while_condition ::= expr
do_while_loop ::= DO_KEYWORD stmt WHILE_KEYWORD LPAREN while_condition RPAREN SEMICOLON

continue_stmt ::= CONTINUE_KEYWORD SEMICOLON
break_stmt ::= BREAK_KEYWORD SEMICOLON

return_stmt ::= RETURN_KEYWORD expr? SEMICOLON

// TODO: dims
local_decl ::= (STATIC_KEYWORD | CONST_KEYWORD)? type_decl symbol (EQ expr)?

expr ::= assignment_expr
       | ternary_expr
       | logical_or_expr
       | logical_and_expr
       | inclusive_or_expr
       | exclusive_or_expr
       | and_expr
       | equality_expr
       | relational_expr
       | shift_expr
       | additive_expr
       | multiplicative_expr
       | unary_group
       | postfix_group
       | primary_expr
       | literal
       { extraRoot = true }

ternary_expr ::= expr QUEST expr COLON expr { pin = 2 }

assignment_expr ::= symbol assignment_op expr {
  pin = 2
  rightAssociative = true
}

private assignment_op ::= EQ
                        | PLUSEQ
                        | MINUSEQ
                        | ASTERISKEQ
                        | DIVEQ
                        | ANDEQ
                        | OREQ
                        | XOREQ
                        | PERCEQ
                        | LTLTEQ
                        | GTGTEQ

private postfix_group ::= subscript_expr
                        | post_increment_expr
                        | post_decrement_expr

private unary_group ::= pre_increment_expr
                      | pre_decrement_expr
                      | ref_expr
                      | deref_expr
                      | positive_expr
                      | negative_expr
                      | not_expr
                      | logical_not_expr

logical_or_expr ::= expr OROR expr { pin = 2 }
logical_and_expr ::= expr ANDAND expr { pin = 2 }
inclusive_or_expr ::= expr XOR expr { pin = 2 }
exclusive_or_expr ::= expr OR expr { pin = 2 }
and_expr ::= expr AND expr { pin = 2 }
equality_expr ::= expr (EQEQ | NE) expr { pin = 2 }
relational_expr ::= expr (LT | GT | LTLTEQ | GTGTEQ) expr { pin = 2 }
shift_expr ::= expr (LTLT | GTGT) expr { pin = 2 }
additive_expr ::= expr (PLUS | MINUS) expr { pin = 2 }
multiplicative_expr ::= expr (ASTERISK | DIV | PERC) expr { pin = 2 }

pre_increment_expr ::= PLUSPLUS expr
pre_decrement_expr ::= MINUSMINUS expr
ref_expr ::= AND expr
deref_expr ::= ASTERISK expr
positive_expr ::= PLUS expr
negative_expr ::= MINUS expr
not_expr ::= TILDE expr
logical_not_expr ::= EXCL expr

post_increment_expr ::= expr PLUSPLUS { pin = 2 }
post_decrement_expr ::= expr MINUSMINUS { pin = 2 }
subscript_expr ::= expr LBRACKET expr RBRACKET { pin=2 }

primary_expr ::= symbol
               | literal
               | paren_expr

paren_expr ::= LPAREN expr RPAREN { pin = 1 }

literal ::= integer_literal
          | float_literal
          | hex_literal
          | binary_literal
          | string_literal
          | character_literal
          { extends = expr }
