
{
  parserClass="org.idea_sp.parser.SourcePawnParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  extends(".*_expr")=expr

  consumeTokenMethod(".*_expr|expr")="consumeTokenFast"

  psiClassPrefix="SourcePawn"
  psiImplClassSuffix="Impl"
  psiPackage="org.idea_sp.psi"
  psiImplPackage="org.idea_sp.psi.impl"

  elementTypeHolderClass="org.idea_sp.psi.SourcePawnTypes"
  elementTypeClass="org.idea_sp.psi.SourcePawnElementType"
  tokenTypeClass="org.idea_sp.psi.SourcePawnTokenType"

  tokens = [
    EQ="="
    EXCL="!"
    TILDE="~"
    QUEST="?"
    COLON=":"
    PLUS="+"
    MINUS="-"
    ASTERISK="*"
    DIV="/"
    OR="|"
    XOR="^"
    PERC="%"
    LPAREN="("
    RPAREN=")"
    LBRACE="{"
    RBRACE="}"
    LBRACKET="["
    RBRACKET="]"
    SEMICOLON=";"
    COMMA=","
    ELLIPSIS="..."
    DOT="."
    EQEQ="=="
    NE="!="
    OROR="||"
    PLUSPLUS="++"
    MINUSMINUS="--"
    LT="<"
    LE="<="
    LTLT="<<"
    GT=">"
    AND="&"
    ANDAND="&&"
    PLUSEQ="+="
    MINUSEQ="-="
    ASTERISKEQ="*="
    DIVEQ="/="
    ANDEQ="&="
    OREQ="|="
    XOREQ="^="
    PERCEQ="%="
    LTLTEQ="<<="
    GTGTEQ=">>="

    ASSERT_KEYWORD="assert"
    BREAK_KEYWORD="break"
    CASE_KEYWORD="case"
    CONTINUE_KEYWORD="continue"
    DEFAULT_KEYWORD="default"
    DO_KEYWORD="do"
    ELSE_KEYWORD="else"
    EXIT_KEYWORD="exit"
    FOR_KEYWORD="for"
    GOTO_KEYWORD="goto"
    IF_KEYWORD="if"
    RETURN_KEYWORD="return"
    SLEEP_KEYWORD="sleep"
    STATE_KEYWORD="state"
    SWITCH_KEYWORD="switch"
    WHILE_KEYWORD="while"
    USING_KEYWORD="using"

    DEFINED_KEYWORD="defined"
    SIZEOF_KEYWORD="sizeof"
    STATE_KEYWORD="state"
    TAGOF_KEYWORD="tagof"

    CONST_KEYWORD="const"
    FORWARD_KEYWORD="forward"
    NATIVE_KEYWORD="native"
    NEW_KEYWORD="new"
    OPERATOR_KEYWORD="operator"
    PUBLIC_KEYWORD="public"
    STATIC_KEYWORD="static"
    STOCK_KEYWORD="stock"

    DECL_KEYWORD="decl"
    NEW_KEYWORD="new"
    PUBLIC_KEYWORD="public"

    // SourcePawn-specific keywords
    ENUM_KEYWORD="enum"
    STRUCT_KEYWORD="struct"
    METHODMAP_KEYWORD="methodmap"
    PROPERTY_KEYWORD="property"

    VIEW_AS_KEYWORD="view_as"

    ANY_TYPE="any"
    VOID_TYPE="void"
    INT_TYPE="int"
    FLOAT_TYPE="float"
    CHAR_TYPE="char"
    BOOL_TYPE="bool"

    line_comment="regexp://[^\r\n]*"
    doc_comment="regexp:/\*\*(.|\n)*?\*/"
    block_comment="regexp:/\*(.|\n)*?\*/"
    preprocessor_comment="regexp:#(assert|define|else|elseif|endif|endinput|error|file|if|include|line|pragma|section|tryinclude|undef)[^\r\n]*"

    integer_literal="regexp:[-+]?\d[_\d]*"
    float_literal="regexp:[-+]?\d[_\d]*\.\d[_\d]*(e[-+]?\d+)?"
    hex_literal="regexp:[-+]?0x[a-fA-F0-9_]+"
    binary_literal="regexp:[-+]?0b[01_]+"

    string_literal="regexp:\"(\\.|[^\"])*\""
    character_literal="regexp:'(\\.|[^\"])'"

    // @ and _ are not themselves valid identifiers.
    identifier="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"

    symbol="regexp:([@_a-zA-Z][@_a-zA-Z0-9]+|[a-zA-Z][@_a-zA-Z0-9]*)"

    // TODO: remove me (for live preview purposes only)
    SPACE="regexp:[ \n\r\t\f]"
  ]
}

private root ::= global*

private meta list ::= <<param>> ( COMMA <<param>> )*

private global ::= global_var_decl_statement
                 | enum_decl SEMICOLON? // XXX: pull out to rule?
                 | func_decl
                 | using_stmt
                 | methodmap
                 | func

global_var_decl_statement ::= global_var_decl SEMICOLON
                            | global_var_decl EQ global_var_initializer SEMICOLON

global_var_decl ::= global_var_storage_class? CONST_KEYWORD? type_expression symbol old_dims?
global_var_storage_class ::= STATIC_KEYWORD | PUBLIC_KEYWORD
global_var_initializer ::= expr | struct

type_expression ::= (builtin_type | symbol) type_dims
private type_dims ::= (LBRACKET RBRACKET)*
private old_dims ::= (LBRACKET expr? RBRACKET)+

private builtin_type ::= ANY_TYPE
                       | VOID_TYPE
                       | INT_TYPE
                       | FLOAT_TYPE
                       | CHAR_TYPE
                       | BOOL_TYPE

tags ::= tag-vector | tag
private tag-vector ::= LBRACE <<list symbol>> RBRACE
private tag ::= symbol COLON { pin = 2 }

struct ::= LBRACE <<list struct_item>> RBRACE
struct_item ::= symbol EQ expr { pin = 2 }  // XXX: be more restrictive?

func_decl ::= (NATIVE_KEYWORD | FORWARD_KEYWORD) type_expression symbol param_list SEMICOLON { pin = 1 }

// Statement is only used in handles.inc, and the parser only allows this incantation
using_stmt ::= USING_KEYWORD '__intrinsics__' DOT 'Handle' SEMICOLON

methodmap ::= METHODMAP_KEYWORD symbol LBRACE methodmap_entry* RBRACE { pin = 1 }
private methodmap_entry ::= methodmap_method | methodmap_prop

methodmap_method ::= methodmap_method_decl | methodmap_method_impl
private methodmap_method_decl ::= PUBLIC_KEYWORD NATIVE_KEYWORD? type_expression symbol param_list SEMICOLON
private methodmap_method_impl ::= PUBLIC_KEYWORD type_expression symbol param_list stmt

methodmap_prop ::= PROPERTY_KEYWORD type_expression symbol LBRACE prop_decl* RBRACE { pin = 1 }
prop_decl ::= prop_method_decl | prop_method_impl
accessor_name ::= 'get' | 'set'
private prop_method_decl ::= PUBLIC_KEYWORD NATIVE_KEYWORD? accessor_name param_list SEMICOLON
private prop_method_impl ::= PUBLIC_KEYWORD accessor_name param_list stmt

func ::= func_storage_class? type_expression symbol param_list stmt
private func_storage_class ::= PUBLIC_KEYWORD
                             | STOCK_KEYWORD STATIC_KEYWORD?
                             | STATIC_KEYWORD STOCK_KEYWORD?

param_list ::= LPAREN <<list param_decl>>? RPAREN { pin = 1 }
param_decl ::= param_decl_old | param_decl_new
private param_decl_old ::= CONST_KEYWORD? tags AND? symbol old_dims? (EQ expr)?
private param_decl_new ::= CONST_KEYWORD? type_expression AND? symbol old_dims? (EQ expr)?

private meta stmt_of ::= <<param>> | <<compound_stmt_of <<param>> >>
private meta compound_stmt_of ::= LBRACE <<param>>* RBRACE { pin = 1 }

private stmt ::= compound_stmt
               | single_stmt

private single_stmt ::= simple_stmt
                      | if_stmt
                      | switch_stmt
                      | for_loop
                      | while_loop
                      | do_while_loop
                      | return_stmt
                      | enum_decl
private compound_stmt ::= <<compound_stmt_of stmt>>

private loop_stmt ::= <<stmt_of (single_stmt | continue_stmt | break_stmt)>>

private simple_stmt ::= simple_expression SEMICOLON { pin = 2 }
private simple_expression ::= local_decl | expr

if_stmt ::= IF_KEYWORD LPAREN expr RPAREN stmt (ELSE_KEYWORD stmt)?

switch_stmt ::= SWITCH_KEYWORD LPAREN expr RPAREN LBRACE (switch_case | switch_default)* RBRACE
switch_case ::= CASE_KEYWORD <<list expr>> COLON stmt
switch_default ::= DEFAULT_KEYWORD COLON stmt

for_loop ::= FOR_KEYWORD LPAREN for_init? SEMICOLON for_condition? SEMICOLON for_iteration? RPAREN loop_stmt
private for_init ::= <<list simple_expression>>
private for_condition ::= expr
private for_iteration ::= expr

while_loop ::= WHILE_KEYWORD LPAREN while_condition RPAREN stmt
private while_condition ::= expr
do_while_loop ::= DO_KEYWORD stmt WHILE_KEYWORD LPAREN while_condition RPAREN SEMICOLON

continue_stmt ::= CONTINUE_KEYWORD SEMICOLON
break_stmt ::= BREAK_KEYWORD SEMICOLON

return_stmt ::= RETURN_KEYWORD expr? SEMICOLON

enum_decl ::= ENUM_KEYWORD symbol LBRACE <<list enum_item>> COMMA? RBRACE { pin = 1 }
enum_item ::= symbol (EQ integer)?

local_decl ::= (STATIC_KEYWORD | CONST_KEYWORD)? type_expression symbol old_dims? local_initializer? { pin = 2 }
private local_initializer ::= EQ expr { pin = 1 }

expr ::= assignment_expr
       | ternary_expr
       | logical_or_expr
       | logical_and_expr
       | inclusive_or_expr
       | exclusive_or_expr
       | and_expr
       | equality_expr
       | relational_expr
       | shift_expr
       | additive_expr
       | multiplicative_expr
       | unary_group
       | postfix_group
       | primary_expr
       | literal
       { extraRoot = true }

ternary_expr ::= expr QUEST expr COLON expr { pin = 2 }

assignment_expr ::= symbol assignment_op expr {
  pin = 2
  rightAssociative = true
}

private assignment_op ::= EQ
                        | PLUSEQ
                        | MINUSEQ
                        | ASTERISKEQ
                        | DIVEQ
                        | ANDEQ
                        | OREQ
                        | XOREQ
                        | PERCEQ
                        | LTLTEQ
                        | GTGTEQ

private postfix_group ::= subscript_expr
                        | post_increment_expr
                        | post_decrement_expr

private unary_group ::= pre_increment_expr
                      | pre_decrement_expr
                      | ref_expr
                      | deref_expr
                      | positive_expr
                      | negative_expr
                      | not_expr
                      | logical_not_expr
                      | view_as_expr

logical_or_expr ::= expr OROR expr { pin = 2 }
logical_and_expr ::= expr ANDAND expr { pin = 2 }
inclusive_or_expr ::= expr XOR expr { pin = 2 }
exclusive_or_expr ::= expr OR expr { pin = 2 }
and_expr ::= expr AND expr { pin = 2 }
equality_expr ::= expr (EQEQ | NE) expr { pin = 2 }
relational_expr ::= expr (LT | GT | LTLTEQ | GTGTEQ) expr { pin = 2 }
shift_expr ::= expr (LTLT | GTGT) expr { pin = 2 }
additive_expr ::= expr (PLUS | MINUS) expr { pin = 2 }
multiplicative_expr ::= expr (ASTERISK | DIV | PERC) expr { pin = 2 }

pre_increment_expr ::= PLUSPLUS expr
pre_decrement_expr ::= MINUSMINUS expr
ref_expr ::= AND expr
deref_expr ::= ASTERISK expr
positive_expr ::= PLUS expr
negative_expr ::= MINUS expr
not_expr ::= TILDE expr
logical_not_expr ::= EXCL expr
view_as_expr ::= VIEW_AS_KEYWORD LT type_expression GT paren_expr

post_increment_expr ::= expr PLUSPLUS { pin = 2 }
post_decrement_expr ::= expr MINUSMINUS { pin = 2 }
subscript_expr ::= expr LBRACKET expr RBRACKET { pin=2 }

primary_expr ::= symbol
               | literal
               | paren_expr

paren_expr ::= LPAREN expr RPAREN { pin = 1 }

literal ::= number
          | string_literal
          | character_literal
          | array_literal
          { extends = expr }

array_literal ::= LBRACE <<list expr>> (COMMA ELLIPSIS)? RBRACE

number ::= integer
         | rational
         { extends = expr }

rational ::= float_literal { extends = expr }

integer ::= integer_literal
          | binary_literal
          | hex_literal
          { extends = expr }
